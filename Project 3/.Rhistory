most_rated.data <- most_rated@data
# replace 0 (no rating) with NULL
most_rated.data[most_rated.data== 0] <- NA
# function to replace the missing value with the median of the column
medValue.f <- function(x){
x[is.na(x)] = median(x, na.rm=TRUE)
return(x)
}
most_rated.data <- apply(most_rated.data, 2, medValue.f)
most_rated@data <- as(most_rated.data, 'dgCMatrix')
most_rated
RMSE <- function(pred,act){
sqrt(mean((pred - act)^2))
}
calcError <- function(dim){
# SVD with specified number of factors
tempRated <- most_rated
SVD <- svd(tempRated@data, nu = dim, nv = dim)
finalMatrix <- SVD$u %*% diag(SVD$d[1:dim]) %*% t(SVD$v)
tempRated@data <- as(finalMatrix, 'dgCMatrix')
# calculate RMSE
return(RMSE(tempRated@data, most_rated@data))
}
# # train/test split - 80/20
#  e <- evaluationScheme(tempRated, method="split", train=0.8,
#    k=1, given=15)
# # build recommender
#rec <- Recommender(getData(e, "train"),
#                   'UBCF',
#                     parameter = list(method = 'cosine',
#                                    nn = 100,
#                                    normalize = 'center'))
# # create predictions for the test data using known ratings
#pred <- predict(rec, getData(e, "known"), type="ratings")
#
# # avg error metrics per user, avgd over all recommendations
#error.ubcf <- calcPredictionAccuracy(pred, getData(e, "unknown"))
#error.ubcf <- c(dim, error.ubcf)
#names(error.ubcf) <- c('k', 'RMSE', 'MSE', 'MAE')
set.seed(200)
eval <- evaluationScheme(most_rated, method = "split",
train = 0.8, given= 20, goodRating=3)
#eval
#Extract train and test data
train <- getData(eval, "train")
known <- getData(eval, "known")
unknown <- getData(eval, "unknown")
tic("UBCF_Model - Train")
modelUBCF <- Recommender(train, method = "UBCF")
toc(log = TRUE, quiet = TRUE)
tic("UBCF_Model - Predict")
predUBCF <- predict(modelUBCF, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
(UBCF_acc <- calcPredictionAccuracy(predUBCF, unknown, byUser = TRUE) )
kable(head(UBCF_acc)) %>% kable_styling(bootstrap_options = "striped", font_size = 12, full_width = F)
#tic("SVD_Model - Train")
modelSVD <- Recommender(train, method = "SVD", parameter = list(k = 20))
toc(log = TRUE, quiet = TRUE)
#tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
SVDacc <- calcPredictionAccuracy(predSVD, unknown, byUser = TRUE)
kable(head(SVDacc)) %>% kable_styling(bootstrap_options = "striped", font_size = 12, full_width = F)
log <- as.data.frame(unlist(tic.log(format = TRUE)))
colnames(log) <- c("Run Time")
knitr::kable(log, format = "html") %>%
kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))
tic("UBCF_Model - Train")
modelUBCF <- Recommender(train, method = "UBCF")
toc(log = TRUE, quiet = TRUE)
tic("UBCF_Model - Predict")
predUBCF <- predict(modelUBCF, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
(UBCF_acc <- calcPredictionAccuracy(predUBCF, unknown, byUser = TRUE) )
kable(head(UBCF_acc)) %>% kable_styling(bootstrap_options = "striped", font_size = 12, full_width = F)
# predicting on known data
tic("UBCF_Model - Predict")
predUBCF <- predict(modelUBCF, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
# calculating accuracy by user
UBCF_acc <- calcPredictionAccuracy(predUBCF, unknown)
kable(head(UBCF_acc)) %>% kable_styling(bootstrap_options = "striped", font_size = 12, full_width = F)
# predicting on known data
tic("UBCF_Model - Predict")
predUBCF <- predict(modelUBCF, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
# calculating accuracy by user
UBCF_acc <- calcPredictionAccuracy(predUBCF, unknown, byUser = TRUE)
kable(head(UBCF_acc)) %>% kable_styling(bootstrap_options = "striped", font_size = 12, full_width = F)
UBCF_acc
# calculating accuracy by user
UBCF_acc <- calcPredictionAccuracy(predUBCF, unknown)
UBCF_acc
head(UBCF_acc)
kable(head(UBCF_acc))
UBCF_acc <- calcPredictionAccuracy(predUBCF, unknown)
kable(head(UBCF_acc))
UBCD_acc
UBCF_acc
UBCF_acc <- calcPredictionAccuracy(predUBCF, unknown, byUser = TRUE)
kable(head(UBCF_acc)) %>% kable_styling(bootstrap_options = "striped", font_size = 12, full_width = F)
#tic("SVD_Model - Train")
modelSVD <- Recommender(train, method = "SVD", parameter = list(k = 20))
toc(log = TRUE, quiet = TRUE)
#tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
SVDacc <- calcPredictionAccuracy(predSVD, unknown, byUser = TRUE)
kable(head(SVDacc)) %>% kable_styling(bootstrap_options = "striped", font_size = 12, full_width = F)
recommenderRegistry$get_entry_names()
#tic("SVD_Model - Train")
modelSVD <- Recommender(train, method = "SVD", parameter = list(k = 20))
toc(log = TRUE, quiet = TRUE)
#tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
SVDacc <- calcPredictionAccuracy(predSVD, unknown, byUser = TRUE)
AVDacc
SVDacc
str(SVDacc)
SVDacc <- data.frame(calcPredictionAccuracy(predSVD, unknown))
str(SVDacc)
View(SVDacc)
calcPredictionAccuracy(predSVD, unknown)
View(calcPredictionAccuracy(predSVD, unknown))
matrix(acc, nrow=len(acc))
acc <- calcPredictionAccuracy(predSVD, unknown)
matrix(acc, nrow=len(acc))
matrix(acc, nrow=length(acc))
matrix(acc, ncol=length(acc))
rownames(acc)
names(acc)
SVDacc <- data.frame(matrix(acc, ncol=length(acc)), colnames <- names(acc))
SVDacc
SVDacc <- data.frame(matrix(acc, ncol=length(acc)), colnames <- c('RMSE', 'MSE', 'MAE'))
SVDacc
SVDacc <- data.frame(matrix(acc, ncol=length(acc)))
colnames(SVDacc) <- c('RMSE', 'MSE', 'MAE')
SVDacc
calcError <- function(dim){
# SVD with specified number of factors
tempRated <- most_rated
SVD <- svd(tempRated@data, nu = dim, nv = dim)
finalMatrix <- SVD$u %*% diag(SVD$d[1:dim]) %*% t(SVD$v)
tempRated@data <- as(finalMatrix, 'dgCMatrix')
# create recommender system
tic("SVD_Model - Train")
modelSVD <- Recommender(train, method = "SVD", parameter = list(k = dim))
toc(log = TRUE, quiet = TRUE)
tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
acc <- calcPredictionAccuracy(predSVD, unknown)
SVDacc <- data.frame(matrix(acc, ncol=length(acc)))
colnames(SVDacc) <- c('RMSE', 'MSE', 'MAE')
errors.ls <- c(RMSE(tempRated@data, most_rated@data),acc)
# calculate RMSE
return(errors.ls)
}
ndim <- 2:3
RMSE.ls <- lapply(nDim, calcError)
nDim <- 2:3
RMSE.ls <- lapply(nDim, calcError)
RMSE.ls
RMSE <- function(pred,act){
list(RMSE.SVD = sqrt(mean((pred - act)^2)))
}
calcError <- function(dim){
# SVD with specified number of factors
tempRated <- most_rated
SVD <- svd(tempRated@data, nu = dim, nv = dim)
finalMatrix <- SVD$u %*% diag(SVD$d[1:dim]) %*% t(SVD$v)
tempRated@data <- as(finalMatrix, 'dgCMatrix')
# create recommender system
tic("SVD_Model - Train")
modelSVD <- Recommender(train, method = "SVD", parameter = list(k = dim))
toc(log = TRUE, quiet = TRUE)
tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
acc <- calcPredictionAccuracy(predSVD, unknown)
errors.ls <- c(RMSE(tempRated@data, most_rated@data),acc)
# calculate RMSE
return(errors.ls)
}
nDim <- 2:3
RMSE.ls <- lapply(nDim, calcError)
RMSE.ls
RMSE <- function(pred,act){
list(RMSE.SVD = sqrt(mean((pred - act)^2)))
}
calcError <- function(dim){
# SVD with specified number of factors
tempRated <- most_rated
SVD <- svd(tempRated@data, nu = dim, nv = dim)
finalMatrix <- SVD$u %*% diag(SVD$d[1:dim]) %*% t(SVD$v)
tempRated@data <- as(finalMatrix, 'dgCMatrix')
# create recommender system
tic("SVD_Model - Train")
modelSVD <- Recommender(train, method = "SVD", parameter = list(k = dim))
toc(log = TRUE, quiet = TRUE)
tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
acc <- calcPredictionAccuracy(predSVD, unknown)
errors.ls <- c(k = dim, RMSE(tempRated@data, most_rated@data),acc)
# calculate RMSE
return(errors.ls)
}
nDim <- 2:3
RMSE.ls <- lapply(nDim, calcError)
RMSE.ls
RMSE <- function(pred,act){
list(RMSE.SVD = sqrt(mean((pred - act)^2)))
}
calcError <- function(dim){
# SVD with specified number of factors
tempRated <- most_rated
SVD <- svd(tempRated@data, nu = dim, nv = dim)
finalMatrix <- SVD$u %*% diag(SVD$d[1:dim]) %*% t(SVD$v)
tempRated@data <- as(finalMatrix, 'dgCMatrix')
# create recommender system
tic("SVD_Model - Train")
modelSVD <- Recommender(train, method = "SVD", parameter = list(k = dim))
toc(log = TRUE, quiet = TRUE)
tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
# calculate accuracy
acc <- calcPredictionAccuracy(predSVD, unknown)
errors.ls <- c(k = dim, RMSE(tempRated@data, most_rated@data), acc)
# return list of k, RMSE for SVD, and accuracy metrics
return(errors.ls)
}
nDim <- 2:min(nrow(most_rated@data), ncol(most_rated@data))
RMSE.ls <- lapply(nDim, calcError)
RMSE.ls
nDim
nDim[-1]
nDim[1]
nDim[-1]
tail(nDim)
tail(nDim, n = 1)
RMSE <- function(pred,act){
list(RMSE.SVD = sqrt(mean((pred - act)^2)))
}
# error calculation for SVD and recommender model
calcError <- function(dim){
# SVD with specified number of factors
tempRated <- most_rated
SVD <- svd(tempRated@data, nu = dim, nv = dim)
finalMatrix <- SVD$u %*% diag(SVD$d[1:dim]) %*% t(SVD$v)
tempRated@data <- as(finalMatrix, 'dgCMatrix')
# create recommender system
tic("SVD_Model - Train")
modelSVD <- Recommender(train, method = "SVD", parameter = list(k = dim/maxDim))
toc(log = TRUE, quiet = TRUE)
# predict on known data
tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
# calculate accuracy for recommender system
acc <- calcPredictionAccuracy(predSVD, unknown)
errors.ls <- c(k = dim, RMSE(tempRated@data, most_rated@data), acc)
# return list of k, RMSE for SVD, and accuracy metrics
return(errors.ls)
}
nDim <- 2:min(nrow(most_rated@data), ncol(most_rated@data))
maxDim <- tail(nDim, n = 1)
RMSE.ls <- lapply(nDim, calcError)
# RMSE function for the SVD
RMSE <- function(pred,act){
list(RMSE.SVD = sqrt(mean((pred - act)^2)))
}
# error calculation for SVD and recommender model
calcError <- function(dim){
# SVD with specified number of factors
tempRated <- most_rated
SVD <- svd(tempRated@data, nu = dim, nv = dim)
finalMatrix <- SVD$u %*% diag(SVD$d[1:dim]) %*% t(SVD$v)
tempRated@data <- as(finalMatrix, 'dgCMatrix')
# create recommender system
tic("SVD_Model - Train")
modelSVD <- Recommender(train, method = "SVD", parameter = list(k = dim/maxDim * 100))
toc(log = TRUE, quiet = TRUE)
# predict on known data
tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
# calculate accuracy for recommender system
acc <- calcPredictionAccuracy(predSVD, unknown)
errors.ls <- c(k = dim, RMSE(tempRated@data, most_rated@data), acc)
# return list of k, RMSE for SVD, and accuracy metrics
return(errors.ls)
}
nDim <- 2:min(nrow(most_rated@data), ncol(most_rated@data))
maxDim <- tail(nDim, n = 1)
RMSE.ls <- lapply(nDim, calcError)
2/332
2/332 * 100
nDim/maxDim
nDim/maxDim * 100
floor(nDim/maxDim * 100)
# recommender error with varying pcts for k-reduction
recError <- function(k_pct) {
# create recommender system
tic("SVD_Model - Train")
modelSVD <- Recommender(train,
method = "SVD",
parameter = list(k = k_pct))
toc(log = TRUE, quiet = TRUE)
# predict on known data
tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
# calculate accuracy
acc <- calcPredictionAccuracy(predSVD, unknown)
# create list of percentage used for recommender system & accuracy
#acc.ls <- c(k_pct = k_pct, acc)
return(acc)
}
pctDim <- 1:100
recError.ls <- lapply(pctDim,recError)
pctDim <- 2:100
recError.ls <- lapply(pctDim,recError)
recError.ls
unlist(recError.ls)
data.frame(recError.ls, ncol(3))
data.frame(recError.ls)
data.frame(unlist(recError.ls))
errors.names <- c("RMSE", "MSE", "MAE")
ubcfErrors.ls <- vector("list", length(errors.names))
names(ubcfErrors.ls) <- errors.names
errors.names
rbind(ubcfErrors.ls,recError.ls)
View(rbind(ubcfErrors.ls,recError.ls))
View(data.frame(rbind(ubcfErrors.ls,recError.ls)))
do.call(“cbind”,recError.ls)
do.call('cbind'”',recError.ls)
do.call('cbind',recError.ls)
do.call('rbind',recError.ls)
View(do.call('rbind',recError.ls))
recError.df <- do.call('rbind',recError.ls)
recError.df$ERROR_MEAN<- rowMeans(subset(recError.df, select = c(RMSE, MSE, MAE)), na.rm = TRUE)
View(recError.df)
recError.df <- do.call('rbind',recError.ls)
recError.df$ERROR_MEAN<- rowMeans(recError.df)
View(recError.df)
recError.df <- do.call('rbind',recError.ls)
View(recError.df)
rowMeans(recError.df[,c(1,2,3)])
recError.df$ERROR_MEAN<- rowMeans(recError.df[,c(1,2,3)])
recError.df <- do.call('rbind',recError.ls)
colnames(recError.df)
recError.df %>%
mutate(ERROR_MEAN = rowMeans(.[1:3]))
str(recError.df)
recError.df <- data.frame(do.call('rbind',recError.ls))
str(recError.df)
rowMeans(recError.df)
recError.df$ERROR_MEAN<- rowMeans(recError.df)
ggplot(recError.df, aes(1:nrow(recError.df))) +
geom_line(aes(y=RMSE), colour="red") +
geom_line(aes(y=MSE), colour="green") +
geom_line(aes(y=MAE), colour="blue") +
geom_line(aes(y=ERROR_MEAN), colour="purple") +
xlab('Trial Run') +
ylab('Error') +
ggtitle('Errors across all runs')
ggplot(recError.df, aes(1:nrow(recError.df))) +
geom_line(aes(y=RMSE), colour="red") +
geom_line(aes(y=MSE), colour="green") +
geom_line(aes(y=MAE), colour="blue") +
geom_line(aes(y=ERROR_MEAN), colour="purple") +
xlab('k-pct') +
ylab('Error') +
ggtitle('Errors across all runs')
ggplot(recError.df, aes(1:nrow(recError.df))) +
geom_line(aes(y=RMSE), colour="red") +
geom_line(aes(y=MSE), colour="green") +
geom_line(aes(y=MAE), colour="blue") +
geom_line(aes(y=ERROR_MEAN), colour="purple") +
xlab('k-pct') +
ylab('Error') +
ggtitle('Errors across all runs') +
theme(legend.position="bottom")
data("MovieLense")
most_rated <- MovieLense[rowCounts(MovieLense) > 50, colCounts(MovieLense) > 100]
most_rated
most_rated.data <- most_rated@data
# replace 0 (no rating) with NULL
most_rated.data[most_rated.data== 0] <- NA
# function to replace the missing value with the median of the column
medValue.f <- function(x){
x[is.na(x)] = median(x, na.rm=TRUE)
return(x)
}
most_rated.data <- apply(most_rated.data, 2, medValue.f)
most_rated@data <- as(most_rated.data, 'dgCMatrix')
most_rated
plot(unlist(RMSE.ls),
main = 'RMSE vs k',
xlab = 'k',
ylab = 'RMSE')
nDim <- 2:min(nrow(most_rated@data), ncol(most_rated@data))
RMSE.ls <- lapply(nDim, calcError)
# RMSE function for the SVD
RMSE <- function(pred,act){
list(RMSE.SVD = sqrt(mean((pred - act)^2)))
}
# error calculation for SVD
calcError <- function(dim){
# SVD with specified number of factors
tempRated <- most_rated
SVD <- svd(tempRated@data, nu = dim, nv = dim)
finalMatrix <- SVD$u %*% diag(SVD$d[1:dim]) %*% t(SVD$v)
tempRated@data <- as(finalMatrix, 'dgCMatrix')
# calculate RMSE for k-reduction
errors.ls <- RMSE(tempRated@data, most_rated@data)
# return list of k and RMSE for SVD
return(errors.ls)
}
nDim <- 2:min(nrow(most_rated@data), ncol(most_rated@data))
RMSE.ls <- lapply(nDim, calcError)
plot(unlist(RMSE.ls),
main = 'RMSE vs k',
xlab = 'k',
ylab = 'RMSE')
plot(unlist(RMSE.ls),
main = 'RMSE vs k',
xlab = 'k',
ylab = 'RMSE')
# recommender error with varying pcts for k-reduction
recError <- function(k_pct) {
# create recommender system
tic("SVD_Model - Train")
modelSVD <- Recommender(train,
method = "SVD",
parameter = list(k = k_pct))
toc(log = TRUE, quiet = TRUE)
# predict on known data
tic("SVD_Model - Predict")
predSVD <- predict(modelSVD, newdata = known, type = "ratings")
toc(log = TRUE, quiet = TRUE)
# calculate accuracy
acc <- calcPredictionAccuracy(predSVD, unknown)
# create list of percentage used for recommender system & accuracy
return(acc)
}
pctDim <- 2:100
recError.ls <- lapply(pctDim,recError)
recError.df <- data.frame(do.call('rbind',recError.ls))
recError.df$ERROR_MEAN<- rowMeans(recError.df)
ggplot(recError.df, aes(1:nrow(recError.df))) +
geom_line(aes(y=RMSE), colour="red") +
geom_line(aes(y=MSE), colour="green") +
geom_line(aes(y=MAE), colour="blue") +
geom_line(aes(y=ERROR_MEAN), colour="purple") +
xlab('k-pct') +
ylab('Error') +
ggtitle('Errors across all runs')
plot(recError.df$RMSE,
main = 'Error for k-% reduction',
xlab = 'k-pct',
ylab = '')
data("MovieLense")
most_rated <- MovieLense[rowCounts(MovieLense) > 50, colCounts(MovieLense) > 100]
most_rated
# split the dataset into test set and train set
which_train <- sample(x = c(TRUE, FALSE), size = nrow(most_rated), replace = TRUE, prob = c(0.8, 0.2))
train_set <- most_rated[which_train, ]
test_set <- most_rated[!which_train, ]
fsvd <- funkSVD(train_set, verbose = TRUE)
### reconstruct the rating matrix as R = UV'
### and calculate the root mean square error on the known ratings
r <- tcrossprod(fsvd$U, fsvd$V)
rmse(train_set, r)
RMSE(train_set, r)
View(train_set)
RMSE(train_set@data, r)
p <- predict(fsvd, test_set)
rmse(test_set@data, p)
RMSE(test_set@data, p)
fsvd <- funkSVD(train_set, k = 332)
### reconstruct the rating matrix as R = UV'
### and calculate the root mean square error on the known ratings
r <- tcrossprod(fsvd$U, fsvd$V)
RMSE(train_set@data, r)
### fold in new users for matrix completion
p <- predict(fsvd, test_set)
RMSE(test_set@data, p)
fsvd <- funkSVD(train_set, k = 5, verbose=TRUE)
### reconstruct the rating matrix as R = UV'
### and calculate the root mean square error on the known ratings
r <- tcrossprod(fsvd$U, fsvd$V)
RMSE(train_set@data, r)
### fold in new users for matrix completion
p <- predict(fsvd, test_set, verbose=TRUE)
RMSE(test_set@data, p)
fsvd <- funkSVD(train_set, k = 10, verbose=TRUE)
### reconstruct the rating matrix as R = UV'
### and calculate the root mean square error on the known ratings
r <- tcrossprod(fsvd$U, fsvd$V)
RMSE(train_set@data, r)
### fold in new users for matrix completion
p <- predict(fsvd, test_set, verbose=TRUE)
RMSE(test_set@data, p)
fsvd <- funkSVD(train_set, k = 20, verbose=TRUE)
### reconstruct the rating matrix as R = UV'
### and calculate the root mean square error on the known ratings
r <- tcrossprod(fsvd$U, fsvd$V)
RMSE(train_set@data, r)
